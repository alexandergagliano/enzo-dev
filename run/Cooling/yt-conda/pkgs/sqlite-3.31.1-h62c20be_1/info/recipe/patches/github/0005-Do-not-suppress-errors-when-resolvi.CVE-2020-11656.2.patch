From 96b6e28400bdbd4470f8f0e5b5b04f26cd0e2f00 Mon Sep 17 00:00:00 2001
From: drh <drh@noemail.net>
Date: Fri, 3 Apr 2020 13:39:03 +0000
Subject: [PATCH] Do not suppress errors when resolving references in an ORDER
 BY clause belonging to a compound SELECT within a view or trigger within
 ALTER TABLE. Fix for ticket [a10a14e9b4ba2]. Also, in the event of a semantic
 error in an aggregate query, early-out the resetAccumulator() function to
 prevent problems due to incomplete or incorrect initialization of the AggInfo
 object. Fix for ticket [af4556bb5c285c08].

FossilOrigin-Name: b64674919f6736025b2066672a5cf5cb51a28bbac4c709b85a1a6163cc0d7971
---
 src/resolve.c      |  2 +-
 src/select.c       |  1 +
 test/altertab.test | 22 ++++++++++++++++++++--
 test/window1.test  | 10 ++++++++++
 4 files changed, 32 insertions(+), 3 deletions(-)

diff --git a/src/resolve.c b/src/resolve.c
index 119a07fd2..894958c19 100644
--- a/src/resolve.c
+++ b/src/resolve.c
@@ -1177,7 +1177,7 @@ static int resolveOrderByTermToExprList(
   nc.nErr = 0;
   db = pParse->db;
   savedSuppErr = db->suppressErr;
-  db->suppressErr = 1;
+  if( IN_RENAME_OBJECT==0 ) db->suppressErr = 1;
   rc = sqlite3ResolveExprNames(&nc, pE);
   db->suppressErr = savedSuppErr;
   if( rc ) return 0;
diff --git a/src/select.c b/src/select.c
index 595b6eb6b..b5e5a75a4 100644
--- a/src/select.c
+++ b/src/select.c
@@ -5352,6 +5352,7 @@ static void resetAccumulator(Parse *pParse, AggInfo *pAggInfo){
   struct AggInfo_func *pFunc;
   int nReg = pAggInfo->nFunc + pAggInfo->nColumn;
   if( nReg==0 ) return;
+  if( pParse->nErr ) return;
 #ifdef SQLITE_DEBUG
   /* Verify that all AggInfo registers are within the range specified by
   ** AggInfo.mnReg..AggInfo.mxReg */
diff --git a/test/altertab.test b/test/altertab.test
index 68c52d604..c99010d29 100644
--- a/test/altertab.test
+++ b/test/altertab.test
@@ -594,7 +594,6 @@ reset_db
 do_execsql_test 18.1.0 {
   CREATE TABLE t0 (c0 INTEGER, PRIMARY KEY(c0)) WITHOUT ROWID;
 }
-breakpoint
 do_execsql_test 18.1.1 {
   ALTER TABLE t0 RENAME COLUMN c0 TO c1;
 }
@@ -636,9 +635,28 @@ do_execsql_test 20.0 {
   CREATE TABLE a(a);
   CREATE VIEW b AS SELECT(SELECT *FROM c JOIN a USING(d, a, a, a) JOIN a) IN();
 }
-
 do_execsql_test 20.1 {
   ALTER TABLE a RENAME a TO e;
 } {}
 
+reset_db
+do_execsql_test 21.0 {
+  CREATE TABLE a(b);
+  CREATE VIEW c AS 
+      SELECT NULL INTERSECT 
+      SELECT NULL ORDER BY
+      likelihood(NULL, (d, (SELECT c)));
+} {}
+do_catchsql_test 21.1 {
+  SELECT likelihood(NULL, (d, (SELECT c)));
+} {1 {second argument to likelihood() must be a constant between 0.0 and 1.0}}
+do_catchsql_test 21.2 {
+  SELECT * FROM c;
+} {1 {1st ORDER BY term does not match any column in the result set}}
+
+do_catchsql_test 21.3 {
+  ALTER TABLE a RENAME TO e;
+} {1 {error in view c: 1st ORDER BY term does not match any column in the result set}}
+
+
 finish_test
diff --git a/test/window1.test b/test/window1.test
index 833e211fb..ca5315ec4 100644
--- a/test/window1.test
+++ b/test/window1.test
@@ -1594,4 +1594,14 @@ do_execsql_test 48.1 {
 } {2 2 2}
 
 
+# 2020-04-03 ticket af4556bb5c285c08
+#
+reset_db
+do_catchsql_test 51.1 {
+  CREATE TABLE a(b, c);
+  SELECT c FROM a GROUP BY c
+    HAVING(SELECT(sum(b) OVER(ORDER BY b),
+                  sum(b) OVER(PARTITION BY min(DISTINCT c), c ORDER BY b)));
+} {1 {row value misused}}
+
 finish_test
-- 
2.25.0

